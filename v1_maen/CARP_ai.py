import copy
import random
import numpy as np

from CARP_solution import Solution

class MAENS:
    """ MA solver:
    Reference: memetic algorithm with extended neighborhood search

    MS operator first merges multiple routes
    to obtain an unordered list of tasks, and then employs PS to
    sort the unordered list.

    After that, Ulusoy’s splitting procedure
    is used to split the ordered lists into new routes in the optimal way.

    Finally, we may obtain five new solutions of CARP by
    embedding the new routes back into the original solution, and
    the best one is chosen as the output of the MS operator
    """

    def __init__(self, info, population_size=100, mutation_rate=0.2):
        self.info = info
        self.mutation_rate = mutation_rate
        self.population_size = population_size

        """ 
            Four commonly used move operators for CARP:
            1. single insertion: 
                a task is removed from its current position and re-inserted into 
                another position of the current solution or a new empty route.
            2. double insertion:
                similar.
                two consecutive tasks are moved instead of a single task
            3. swap:
                two candidate tasks are selected and their positions are exchanged
            4. 2-opt:
            4.1) single route:
                a subroute (part of the route) is selected and its direction is reversed
            4.2) double route:
                 each route is first cut into two subroutes, and new solutions are 
                 generated by reconnecting the four subroutes
        """
        self.operations = [self.single_insertion, self.double_insertion, self.swap]

        """ Five rules in path scanning phase (PS)
         If multiple tasks not only satisfy the capacity constraints 
         but are the closest to the end of the current path
        1. maximize the distance from the head of task to the depot
        2. minimize the distance from the head of task to the depot
        3.  maximize the term dem(t)/sc(t), 
            where dem(t) and sc(t) are demand and serving cost of task t
        4. minimize the term dem(t)/sc(t)
        5. use rule 1) if the vehicle is less than half-full, otherwise use rule 2)
         
        PS does not use the five rules alternatively. 
        Instead, it scans the unordered list of tasks for five times.
        In each scan, only one rule is used.
        Hence, PS will generate five ordered lists of tasks in total
        """
        from_head_to_depot = lambda x: self.info.min_dist[x, self.info.depot]
        self.rules = [
            lambda x, y, c: from_head_to_depot(x.v) > from_head_to_depot(y.v),
            lambda x, y, c: from_head_to_depot(x.v) < from_head_to_depot(y.v),
            lambda x, y, c: x.demand / x.cost > y.demand / y.cost,
            lambda x, y, c: x.demand / x.cost < y.demand / y.cost,
            lambda x, y, c: from_head_to_depot(x.v) > from_head_to_depot(y.v) if c < self.info.capacity / 2
            else from_head_to_depot(x.v) < from_head_to_depot(y.v)
        ]
        """ In Split component, 
        Ulusoy's splitting method is applied to all the five ordered lists
        (Ulusoy's splitting: 
            seeks the optimal way to split the ordered list into different routes)
        """

        self.population = self.init()

    def init(self):
        population = set()
        """
        PS does not use the five rules alternatively. 
        Instead, it scans the unordered list of tasks for five times. 
        In each scan, only one rule is used
        """
        for rule in self.rules:
            solution = self.path_scanning(rule)
            population.add(solution)
        """Hence, PS will generate five ordered lists of tasks in total"""
        parents = copy.copy(population)

        # extend to population size
        while len(population) < self.population_size:
            for p in parents:
                operation = random.choice(self.operations)
                new_solution = operation(p)
                if random.random() > new_solution.discard_chance:
                    population.add(new_solution)
        return population

    def is_better(self, edge, selected_task, current_load, rule):
        return rule(edge, selected_task, current_load)

    def path_scanning(self, rule):
        # unordered list of path
        available = self.info.tasks.copy()
        routes = []
        loads = []
        costs = []

        info = self.info
        while available:
            last_end = info.depot
            routes.append([])
            loads.append(0)
            costs.append(0)
            while available:
                # selected_edge = list(available.values())[0]
                selected_edge = None
                min_d = np.inf
                for edge in [x for x in available.values() if loads[-1] + x.demand <= info.capacity]:
                    d = info.min_dist[last_end, edge.u]
                    if d < min_d:
                        min_d = d
                        selected_edge = edge
                    elif d == min_d and self.is_better(edge, selected_edge, loads[-1], rule):
                        selected_edge = edge

                if min_d == np.inf:   # distance does not update
                    break

                routes[-1].append((selected_edge.u, selected_edge.v))
                available.pop((selected_edge.u, selected_edge.v))
                available.pop((selected_edge.v, selected_edge.u))

                loads[-1] += selected_edge.demand
                costs[-1] += selected_edge.cost + min_d
                last_end = selected_edge.v

            costs[-1] += info.min_dist[last_end, info.depot]

        solution = Solution(routes, loads, costs, sum(costs), info.capacity)
        return solution

    def single_insertion(self, solution: Solution):
        """
        Move operator: Single Insertion
         A task is removed from its current position
         and re-inserted into another position of the current solution or a new empty route.

         If the selected task belongs to an edge task, both its directions will
         be considered when inserting the task into the “target position.”

        :param solution: parent
        :return: child generated by Single Insertion
        """
        info = self.info
        new_solution = copy.deepcopy(solution)

        routes = new_solution.routes
        route_idx = random.randrange(0, len(routes))
        selected_route = routes[route_idx]

        task_idx = random.randrange(0, len(selected_route))
        u, v = selected_route[task_idx]
        task = info.tasks[(u, v)]

        # calculate changed selected arc costs
        prev_tail = selected_route[task_idx - 1][1] if task_idx != 0 else info.depot
        next_head = selected_route[task_idx + 1][0] if task_idx != len(selected_route) - 1 else info.depot
        cost_diff = info.min_dist[prev_tail, next_head] \
                    - info.min_dist[prev_tail, u] - info.min_dist[v, next_head] \
                    - task.cost

        new_solution.costs[route_idx] += cost_diff
        new_solution.total_cost += cost_diff
        new_solution.loads[route_idx] -= task.demand
        selected_task = selected_route.pop(task_idx)

        # get inserted index
        routes.append([])
        insert_route_idx = random.randrange(0, len(routes))
        insert_route = routes[insert_route_idx]
        insert_position = random.randint(0, len(insert_route))  # start <= N <= end

        # calculate changed inserted arc costs
        prev_tail = insert_route[insert_position - 1][1] if insert_position != 0 else info.depot
        next_head = insert_route[insert_position][0] if insert_position != len(insert_route) else info.depot

        cost_diff = info.min_dist[prev_tail, u] + info.min_dist[v, next_head] \
                    + task.cost - info.min_dist[prev_tail, next_head]
        reversed_cost_diff = info.min_dist[prev_tail, v] + info.min_dist[u, next_head] + task.cost - info.min_dist[prev_tail, next_head]  # (v, u)
        if reversed_cost_diff < cost_diff:
            selected_task = (v, u)
            cost_diff = reversed_cost_diff

        if not insert_route:  # means a new arc
            new_solution.costs.append(cost_diff)
            new_solution.loads.append(task.demand)
        else:
            del routes[-1]
            new_solution.costs[insert_route_idx] += cost_diff
            new_solution.loads[insert_route_idx] += task.demand
        new_solution.total_cost += cost_diff

        insert_route.insert(insert_position, selected_task)
        new_solution.validate()
        return new_solution


    def double_insertion(self, solution):
        info = self.info
        new_solution = copy.deepcopy(solution)

        routes = new_solution.routes
        route_idx = random.randrange(0, len(routes))
        while len(routes[route_idx]) < 2:
            route_idx = random.randrange(0, len(routes))

        selected_route = routes[route_idx]
        task_idx = random.randrange(0, len(selected_route) - 1)

        u1, v1 = selected_route[task_idx]
        u2, v2 = selected_route[task_idx + 1]
        task1 = info.tasks[(u1, v1)]
        task2 = info.tasks[(u2, v2)]

        # calculate changed selected arc costs
        prev_tail = selected_route[task_idx - 1][1] if task_idx != 0 else info.depot
        next_head = selected_route[task_idx + 2][0] if task_idx != len(selected_route) - 2 else info.depot

        cost_diff = info.min_dist[prev_tail, next_head] - info.min_dist[prev_tail, u1] \
                    - task1.cost - info.min_dist[v1, u2] \
                    - task2.cost - info.min_dist[v2, next_head]
        new_solution.costs[route_idx] += cost_diff
        new_solution.total_cost += cost_diff
        new_solution.loads[route_idx] -= task1.demand + task2.demand

        selected_task1 = selected_route.pop(task_idx)
        selected_task2 = selected_route.pop(task_idx)

        # get inserted index
        routes.append([])
        insert_route_idx = random.randrange(0, len(routes))
        insert_route = routes[insert_route_idx]
        insert_position = random.randint(0, len(insert_route))

        # calculate changed inserted arc costs
        prev_tail = insert_route[insert_position - 1][1] if insert_position != 0 else info.depot
        next_head = insert_route[insert_position][0] if insert_position != len(insert_route) else info.depot

        cost_diff = info.min_dist[prev_tail, u1] \
                    + task1.cost + info.min_dist[v1, u2] \
                    + task2.cost + info.min_dist[v2, next_head] \
                    - info.min_dist[prev_tail, next_head]
        reversed_cost_diff = info.min_dist[prev_tail, v2] \
                             + task1.cost + info.min_dist[u2, v1] \
                             + task2.cost + info.min_dist[u1, next_head] \
                             - info.min_dist[prev_tail, next_head]
        if reversed_cost_diff < cost_diff:
            selected_task1 = (v2, u2)
            selected_task2 = (v1, u1)
            cost_diff = reversed_cost_diff

        if not insert_route:  # means a new arc
            new_solution.costs.append(cost_diff)
            new_solution.loads.append(task1.demand + task2.demand)
        else:
            del routes[-1]
            new_solution.costs[insert_route_idx] += cost_diff
            new_solution.loads[insert_route_idx] += task1.demand + task2.demand
        new_solution.total_cost += cost_diff
        insert_route.insert(insert_position, selected_task2)
        insert_route.insert(insert_position, selected_task1)

        new_solution.validate()
        return new_solution

    def swap(self, solution):
        new_solution = copy.deepcopy(solution)
        info = self.info
        routes = new_solution.routes

        # select first task
        route_idx_1 = random.randrange(0, len(routes))
        select_route_1 = routes[route_idx_1]
        task_idx_1 = random.randrange(0, len(select_route_1))
        u1, v1 = select_route_1[task_idx_1]
        task1 = info.tasks[(u1, v1)]
        prev_tail1 = select_route_1[task_idx_1 - 1][1] if task_idx_1 != 0 else info.depot
        next_head1 = select_route_1[task_idx_1 + 1][0] if task_idx_1 != len(select_route_1)-1 else info.depot

        # select second task
        route_idx_2 = route_idx_1
        select_route_2 = None
        task_idx_2 = task_idx_1
        while route_idx_2 == route_idx_1 and task_idx_2 == task_idx_1:
            route_idx_2 = random.randrange(0, len(routes))
            select_route_2 = routes[route_idx_2]
            task_idx_2 = random.randrange(0, len(select_route_2))
        u2, v2 = select_route_2[task_idx_2]
        task2 = info.tasks[(u2, v2)]
        prev_tail2 = select_route_2[task_idx_2 - 1][1] if task_idx_2 != 0 else info.depot
        next_head2 = select_route_2[task_idx_2 + 1][0] if task_idx_2 != len(select_route_2)-1 else info.depot

        selected_task1 = select_route_1.pop(task_idx_1)
        if route_idx_1 == route_idx_2 and task_idx_1 < task_idx_2:
            selected_task2 = select_route_2.pop(task_idx_2 - 1)
        else:
            selected_task2 = select_route_2.pop(task_idx_2)

        # calculate cost1 change
        reduced_cost_1 = info.min_dist[prev_tail1, u1] + task1.cost \
                         + info.min_dist[v1, next_head1]
        cost_diff_1 = info.min_dist[prev_tail1, u2] + task2.cost \
                      + info.min_dist[v2, next_head1] - reduced_cost_1
        reversed_cost_diff_1 = info.min_dist[prev_tail1, v2] + task2.cost + info.min_dist[u2, next_head1] - reduced_cost_1
        if reversed_cost_diff_1 < cost_diff_1:
            selected_task2 = (v2, u2)
            cost_diff_1 = reversed_cost_diff_1

        # insert task2 into route1
        new_solution.costs[route_idx_1] += cost_diff_1
        new_solution.total_cost += cost_diff_1
        new_solution.loads[route_idx_1] += (task2.demand - task1.demand)
        select_route_1.insert(task_idx_1, selected_task2)

        # calculate cost2 change
        reduced_cost_2 = info.min_dist[prev_tail2, u2] + task2.cost \
                         + info.min_dist[v2, next_head2]
        cost_diff_2 = info.min_dist[prev_tail2, u1] + task1.cost \
                      + info.min_dist[v1, next_head2] - reduced_cost_2
        reversed_cost_diff_2 = info.min_dist[prev_tail2, v1] + task1.cost \
                               + info.min_dist[u1, next_head2] - reduced_cost_2

        if reversed_cost_diff_2 < cost_diff_2:
            selected_task1 = (v1, u1)
            cost_diff_2 = reversed_cost_diff_2

        # insert task1 into route2
        new_solution.costs[route_idx_2] += cost_diff_2
        new_solution.total_cost += cost_diff_2
        new_solution.loads[route_idx_2] += (task1.demand - task2.demand)

        select_route_2.insert(task_idx_2, selected_task1)

        if route_idx_1 == route_idx_2:
            new_solution.total_cost = new_solution.quality(info)

        new_solution.validate()
        return new_solution


    def two_opt(self, solution):
        """ Two types of 2-opt move:
        1. Single Route:
            A subroute (a part of the route) is selected and its direction is reserved.
        2. Double Route:
            Each route is first cut into two subroutes, and new solutions are generated by
            reconnecting the four subroutes

        2-opt operator is only applicable to edge tasks
        """


    def get_quality(self, solution: Solution):
        return solution.total_cost

    def local_search(self, solution: Solution):
        while True:
            new_solution = min([operation(solution) for operation in self.operations], key=self.get_quality)
            discard_chance = 0 if new_solution.is_valid else 0.6
            # discard_chance = new_solution.discard_chance
            if random.random() > discard_chance:
                return new_solution

    def run(self):
        for solution in self.population.copy():
            if random.random() > solution.discard_chance:
                if random.random() > self.mutation_rate:
                    new_solution = min([operation(solution) for operation in self.operations], key=self.get_quality)
                    if random.random() > new_solution.discard_chance:
                        self.population.add(new_solution)
            else:
                self.population.remove(solution)

        while len(self.population) > self.population_size:
            worst = max(self.population, key=self.get_quality)
            self.population.remove(worst)

        valid_population = [p for p in self.population if p.is_valid]
        return min(valid_population, key=self.get_quality)
