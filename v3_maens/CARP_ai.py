import copy
import random

import numpy as np
from itertools import combinations

from CARP_utils import Solution, Insert, Move, calculate_fitness

Mtrial = 10
Mprob = 0.2
Gmax = 100
Mwite = 100

MAX_TASK_TAG_LENGTH = 500
MAX_TASK_SEG_LENGTH = 550
MAX_TASK_SEQ_LENGTH = 500
task_routes = np.zeros((101, MAX_TASK_SEG_LENGTH), dtype=int)

MAX_NSIZE = 10  # upper bound of n size
MAX_ENSSIZE = 100  # max ENS neighborhood size


def find_element_position(position, arr, e):
    position[0] = 0
    for i in range(1, arr[0] + 1):
        if arr[i] == e:
            position[0] += 1
            position[position[0]] = i
    return position


def del_element_by_i(arr: list, k):
    arr.pop(k)

def del_element_by_e(arr: list, e):
    arr.remove(e)

def add_element(arr, e, k):
    arr.insert(k, e)

def assign_subroute(src, k1, k2):
    return src[k1:k2 + 1]

def join_routes(joint_arr: list, arr: list):
    joint_arr.extend(arr)

def ind_route_converter(src: Solution, inst_task):
    load = 0
    task_seq = np.zeros(MAX_TASK_SEQ_LENGTH, dtype=int)
    loads = np.zeros(50, dtype=int)
    task_seq[0] = 1
    task_seq[1] = 0

    for i in range(2, src.task_seq[0] + 1):
        if src.task_seq[i] == 0:
            task_seq[0] += 1
            task_seq[task_seq[0]] += 0
            loads[0] += 1
            loads[loads[0]] = load
            load = 0
            continue
        load += inst_task[src.task_seq[i]].demand
        task_seq[0] += 1
        task_seq[task_seq[0]] = src.task_seq[i]
    return Solution(task_seq=task_seq, loads=loads, quality=src.quality, exceed_load=0)


def get_quality(solution: Solution):
    return solution.quality


def is_better(curr, prev, current_load, rule):
    return rule(curr, prev, current_load)


class MAENS:
    def __init__(self, info):
        # 任务信息初始化
        self.tasks = info.tasks
        self.req_edge_num = info.edges_required
        self.task_num = self.req_edge_num * 2
        self.non_req_edge_num = info.edges_non_req
        self.edge_total = self.req_edge_num + self.non_req_edge_num
        self.capacity = info.capacity
        self.depot = info.depopt
        self.min_dist = info.min_dist
        self.dummy_node = (self.depot, self.depot)

        # 种群大小
        self.psize = 30
        self.population = []
        # 初始化寻找种群的最大迭代数
        self.ubtrial = 50
        # 每次迭代生成的后代数量
        self.opsize = 6 * self.psize
        # 每回合生成的解的总数
        self.total_size = self.psize + self.opsize
        # Probability of carrying out local search (mutation)
        self.pls = 0.2
        # Number of routes involved in Merge-Split operator
        self.p = 2
        # Max number of generation
        self.Gmax = 500
        # Max number of solution generated by M-S operator (max ENS neighborhood size)
        self.ENSsize = 100

        self.operations = [self.single_insertion, self.double_insertion, self.swap]

        from_head_to_depot = lambda x: self.min_dist[x, self.depot]
        self.rules = [
            lambda x, y, c: from_head_to_depot(x.v) > from_head_to_depot(y.v),
            lambda x, y, c: from_head_to_depot(x.v) < from_head_to_depot(y.v),
            lambda x, y, c: x.demand / x.cost > y.demand / y.cost,
            lambda x, y, c: x.demand / x.cost < y.demand / y.cost,
            lambda x, y, c: from_head_to_depot(x.v) > from_head_to_depot(y.v) if c < self.info.capacity / 2
            else from_head_to_depot(x.v) < from_head_to_depot(y.v)
        ]

    def rand_scanning(self):
        unserved_task = self.tasks.copy()
        task_seq = []
        loads = []
        costs = []

        while unserved_task:
            last_end = self.depot
            task_seq.append([self.dummy_node])
            loads.append(0)
            costs.append(0)

            while unserved_task:
                candidate_tasks = None
                mindist = np.inf
                for task in [x for x in unserved_task.values() if loads[-1] + x.demand <= self.capacity]:
                    d = self.min_dist[last_end, task.u]
                    if d < mindist:
                        mindist = d
                        candidate_tasks = [task]
                    elif d == mindist:
                        candidate_tasks.append(task)
                if not candidate_tasks:
                    # 没有可选的task了
                    break
                next_task = random.choice(candidate_tasks)

                task_seq[-1].append((next_task.u, next_task.v))
                unserved_task.pop((next_task.u, next_task.v))
                unserved_task.pop((next_task.v, next_task.u))

                loads[-1] += next_task.demand
                costs[-1] += next_task.cost
                last_end = next_task.v
            task_seq[-1].append(self.dummy_node)
            costs[-1] += self.min_dist[last_end, self.depot]

        quality = sum(costs)
        exceed_load = self.get_exceed_loads(loads)
        return Solution(task_seq, costs, loads, quality, exceed_load)

    def path_scanning(self, serve_mark):
        """Use five rules  to obtain solution"""
        solution_list = []
        for rule in self.rules:
            unserved_tasks = dict()
            for tsk, is_served in serve_mark:
                if not is_served:
                    u, v = tsk
                    task_obj = self.tasks[(u, v)]
                    unserved_tasks[(u, v)] = task_obj
                    unserved_tasks[(v, u)] = task_obj

            tmp_ind = self.path_scanning_with_rule(unserved_tasks.copy(), rule)
            solution_list.append(tmp_ind)
        return min(solution_list, key=get_quality)

    def path_scanning_with_rule(self, unserved_task, rule):
        task_seq = []
        loads = []
        costs = []

        while unserved_task:
            last_end = self.depot
            task_seq.append([self.dummy_node])
            loads.append(0)
            costs.append(0)

            while unserved_task:
                next_task = None
                mindist = np.inf
                for task in [x for x in unserved_task.values() if loads[-1] + x.demand <= self.capacity]:
                    d = self.min_dist[last_end, task.u]
                    if d < mindist:
                        mindist = d
                        next_task = task
                    elif d == mindist and is_better(task, next_task, loads[-1], rule):
                        next_task = task
                if not next_task:
                    # 没有可选的task了
                    break

                task_seq[-1].append((next_task.u, next_task.v))
                unserved_task.pop((next_task.u, next_task.v))
                unserved_task.pop((next_task.v, next_task.u))

                loads[-1] += next_task.demand
                costs[-1] += next_task.cost
                last_end = next_task.v
            task_seq.append(self.dummy_node)
            costs[-1] += self.min_dist[last_end, self.depot]

        quality = sum(costs)
        exceed_load = self.get_exceed_loads(loads)
        return Solution(task_seq, costs, loads, quality, exceed_load)


    def get_exceed_loads(self, route_seg_load):
        exceed_loads = [max(load - self.capacity, 0) for load in route_seg_load]
        return sum(exceed_loads)

    def SBX(self, s1, s2):
        """ Sequence Based Crossover Operator
            S1 -> {R11, R12}
            S2 -> {R21, R22}
            Sx -> {任意拼接}
            remove duplicate task in NewR and insert missing task to NewR -> offspring
        """
        routes1 = s1.task_seq.copy()
        routes2 = s2.task_seq.copy()

        """ define: candidate selection:
                (routeID, position)
        """

        xclds = s1.loads.copy()
        candidate_list1 = s1.task_seq.copy()
        candidate_list2 = s2.task_seq.copy()

        sel_routeID_1 = random.randrange(0, len(candidate_list1))
        sel_routeID_2 = random.randrange(0, len(candidate_list2))

        sel_pos_1 = random.randrange(1, len(candidate_list1[sel_routeID_1]) - 1)
        sel_pos_2 = random.randrange(1, len(candidate_list2[sel_routeID_2]) - 1)
        while sel_routeID_1 == sel_pos_2 and sel_pos_1 == sel_pos_2:
            sel_routeID_2 = random.randrange(0, len(candidate_list2))
            sel_pos_2 = random.randrange(1, len(candidate_list2[sel_routeID_2]) - 1)

        sub_path1 = assign_subroute(routes1[sel_routeID_1], 1, sel_pos_1)
        sub_path2 = assign_subroute(routes2[sel_routeID_2], sel_pos_2, len(routes2[sel_routeID_2]) - 2)
        left_tasks = assign_subroute(routes1[sel_routeID_1], sel_pos_1 + 1, len(routes1[sel_routeID_1]) - 2)

        # remove duplicated task for routes1
        checked = dict()
        for tsk2 in sub_path2:
            u2, v2 = tsk2
            for i, tsk1 in enumerate(sub_path1):
                u1, v1 = tsk1
                if (u1 == u2 and v1 == v2) or (v1 == u2 and u1 == v2):
                    checked[tsk2] = True
                    sub_path1.pop(i)
                    break
            if checked[tsk2]:
                continue

            for i, tsk_left in enumerate(left_tasks):
                u1, v1 = tsk_left
                if (u1 == u2 and v1 == v2) or (v1 == u2 and u1 == v2):
                    checked[tsk2] = True
                    left_tasks.pop(i)
                    break

            if checked[tsk2]:
                continue

            for i, route in enumerate(routes1):
                if i == sel_routeID_1:
                    continue
                for j, tsk1 in enumerate(route[1:len(route)-1]):
                    u1, v1 = tsk1
                    if (u1 == u2 and v1 == v2) or (v1 == u2 and u1 == v2):
                        checked[tsk2] = True
                        route.pop(i)
                        break

        join_routes(sub_path1, sub_path2)
        routes1[sel_routeID_1][1:len(routes1[sel_routeID_1])-1] = sub_path1.copy()
        xclds[sel_routeID_1] = sum([self.tasks[tsk].demand for tsk in sub_path1])

        # insert missing tasks
        candidate_insertions = [None] * 6000
        pare_to_set_insertions = [None] * 6000
        out = np.empty(6000, dtype=int)
        for n, (u, v) in enumerate(left_tasks):
            candidate_insert_cnt = 0
            pare_to_set_size = 0
            curr_task = self.tasks[(u, v)]
            for j, route in enumerate(routes1):
                if not route:
                    continue
                if xclds[j] > self.capacity:
                    ivload = curr_task.demand
                elif xclds[j] + curr_task.demand > self.capacity:
                    ivload = xclds[j] + curr_task.demand - self.capacity
                else:
                    ivload = 0
                # 向原有路径插入
                for k in range(1, len(route)):
                    candidate_insert_cnt += 1
                    insert_cost = self.min_dist[self.tasks[route[k - 1]].v, u] \
                                  + self.min_dist[v, self.tasks[route[k]].u] \
                                  - self.min_dist[self.tasks[route[k - 1]].v, self.tasks[route[k]].u]
                    # curr_task: 被选中的未被插入的task
                    # j: 要插入的routeID
                    # k: 被插入的route中对应的position
                    # cost: 插入之后增加的cost
                    # ivload: 插入之后增加的load
                    candidate_insertions[candidate_insert_cnt] = Insert(task=(u, v), routeID=j, position=k,
                                                                        cost=insert_cost, exceed_load=ivload)

                    out[0] = 0
                    add = True
                    for m in range(1, pare_to_set_size + 1):
                        cand_insert: Insert = candidate_insertions[candidate_insert_cnt]
                        if cand_insert.cost > pare_to_set_insertions[m].cost and \
                                cand_insert.exceed_load > pare_to_set_insertions[m].exceed_load:
                            add = False
                            break
                        elif cand_insert.cost < pare_to_set_insertions[m].cost and \
                                cand_insert.exceed_load < pare_to_set_insertions[m].exceed_load:
                            out[0] += 1
                            out[out[0]] = m
                    if add:
                        for m in range(out[0], 0, -1):
                            pare_to_set_insertions[out[m]:pare_to_set_size] = pare_to_set_insertions[out[m] + 1:pare_to_set_size + 1]
                            pare_to_set_size -= 1
                        pare_to_set_size += 1
                        pare_to_set_insertions[pare_to_set_size] = candidate_insertions[candidate_insert_cnt]

                    candidate_insert_cnt += 1
                    insert_cost = self.min_dist[self.tasks[route[k - 1]].v, v] \
                                  + self.min_dist[u, self.tasks[route[k]].u] \
                                  - self.min_dist[self.tasks[route[k - 1]].v, self.tasks[route[k]].u]
                    candidate_insertions[candidate_insert_cnt] = Insert(task=(v, u), routeID=j, position=k,
                                                                        cost=insert_cost, exceed_load=ivload)

                    out[0] = 0
                    add = True
                    for m in range(1, pare_to_set_size + 1):
                        cand_insert: Insert = candidate_insertions[candidate_insert_cnt]
                        if cand_insert.cost > pare_to_set_insertions[m].cost and \
                                cand_insert.exceed_load > pare_to_set_insertions[m].exceed_load:
                            add = False
                            break
                        elif cand_insert.cost < pare_to_set_insertions[m].cost and \
                                cand_insert.exceed_load < pare_to_set_insertions[m].exceed_load:
                            out[0] += 1
                            out[out[0]] = m
                    if add:
                        for m in range(out[0], 0, -1):
                            pare_to_set_insertions[out[m]:pare_to_set_size] = pare_to_set_insertions[
                                                                              out[m] + 1:pare_to_set_size + 1]
                            pare_to_set_size -= 1
                        pare_to_set_size += 1
                        pare_to_set_insertions[pare_to_set_size] = candidate_insertions[candidate_insert_cnt]

                # insert as a new route
                candidate_insert_cnt += 1
                insert_cost = self.min_dist[self.depot, u] + self.min_dist[v, self.depot]
                candidate_insertions[candidate_insert_cnt] = Insert(task=(u, v), routeID=-1, position=1,
                                                                    cost=insert_cost, exceed_load=0)

                out[0] = 0
                add = True
                for m in range(1, pare_to_set_size + 1):
                    cand_insert: Insert = candidate_insertions[candidate_insert_cnt]
                    if cand_insert.cost > pare_to_set_insertions[m].cost and \
                            cand_insert.exceed_load > pare_to_set_insertions[m].exceed_load:
                        add = False
                        break
                    elif cand_insert.cost < pare_to_set_insertions[m].cost and \
                            cand_insert.exceed_load < pare_to_set_insertions[m].exceed_load:
                        out[0] += 1
                        out[out[0]] = m
                if add:
                    for m in range(out[0], 0, -1):
                        pare_to_set_insertions[out[m]:pare_to_set_size] = pare_to_set_insertions[
                                                                          out[m] + 1:pare_to_set_size + 1]
                        pare_to_set_size -= 1
                    pare_to_set_size += 1
                    pare_to_set_insertions[pare_to_set_size] = candidate_insertions[candidate_insert_cnt]

                k = random.randrange(1, pare_to_set_size + 1)
                best_insertion: Insert = pare_to_set_insertions[k]
                if best_insertion.routeID == -1:
                    routes1.append([self.dummy_node, best_insertion.task, self.dummy_node])
                    xclds.append([self.tasks[best_insertion].demand])
                    best_insertion.routeID = len(xclds) - 1
                else:
                    add_element(routes1[best_insertion.routeID], best_insertion.task, best_insertion.position)
                    xclds[best_insertion.routeID] += self.tasks[best_insertion.task].demand

        # transfer routes1 to sequence
        task_seq = []
        loads = []
        costs = []
        exceed_load = 0
        for i, route in enumerate(routes1):
            if not route:
                continue
            task_seq.append(route)
            loads.append(xclds[i])
            exceed_load += max(loads[-1] - self.capacity)
            cost = 0
            for j in range(1, len(route)-1):
                cost += self.min_dist[self.tasks[route[j - 1]].v, self.tasks[route[j]].u] \
                        + self.min_dist[self.tasks[route[j]].v, self.tasks[route[j+1]].u] \
                        + self.tasks[route[j]].cost
            costs.append(cost)
        return Solution(task_seq, costs, loads, sum(costs), exceed_load)


    def lns_mut(self, sx: Solution, best_fsb_solution: Solution):
        sls = copy.deepcopy(sx)
        coef = best_fsb_solution.quality / self.capacity * (
                best_fsb_solution.quality / sx.quality + sx.exceed_load / self.capacity + 1.0)
        calculate_fitness(sls, coef)

        count, count1 = 0, 0
        count_fsb, count_infsb = 0, 0

        nsize_arr = [1, 2, 1]
        for nsize in nsize_arr:
            imp = True  # improved
            count1 = 0
            while imp:
                count += 1
                count1 += 1
                imp = False

                if sls.exceed_load == 0:
                    count_fsb += 1
                else:
                    count_infsb += 1

                if count % 5 == 0:
                    # 系数随着迭代次数和可行解数量改变
                    if count_fsb == 5:
                        coef /= 5
                        calculate_fitness(sls, coef)
                    elif count_infsb == 5:
                        coef *= 5
                        calculate_fitness(sls, coef)
                    count_fsb = 0
                    count_infsb = 0

                # tmp_ind = copy.deepcopy(sls)
                prev_fitness = sls.fitness
                prev_quality = sls.quality
                # traditional operator
                sls = self.lns(sls, coef, nsize)
                if sls.fitness < prev_fitness:
                    imp = True
                if count1 > self.ubtrial and sls.quality < prev_quality:
                    break
                if sls.exceed_load == 0 and sls.quality < best_fsb_solution.quality:
                    best_fsb_solution = copy.deepcopy(sls)
        return sls, best_fsb_solution

    def get_fitness(self, move: Move):
        return move.fitness

    def lns(self, ind: Solution, coef, nsize):
        calculate_fitness(ind, coef)

        if nsize == 1:
            # traditional move
            next_move: Move = min([move(ind, coef) for move in self.operations], key=self.get_fitness)

            if next_move.type == 1:
                # single insertion
                del_element_by_i(ind.task_seq[next_move.orig_seg], next_move.orig_pos)
                if next_move.orig_seg == next_move.targ_seg and next_move.targ_pos > next_move.orig_pos:
                    next_move.targ_pos -= 1
                ind.loads[next_move.orig_seg] -= self.tasks[next_move.task1].demand

                if next_move.targ_seg > len(ind.loads):
                    ind.task_seq.append([self.dummy_node, next_move.task1, self.dummy_node])
                    ind.loads.append([self.tasks[next_move.task1].demand])
                else:
                    add_element(ind.task_seq[next_move.targ_seg], next_move.task1, next_move.targ_pos)
                    ind.loads[next_move.targ_seg] += self.tasks[next_move.task1].demand
            elif next_move.type == 2:
                # doubel insertion
                del_element_by_i(ind.task_seq[next_move.orig_seg], next_move.orig_pos + 1)
                del_element_by_i(ind.task_seq[next_move.orig_seg], next_move.orig_pos)
                if next_move.orig_seg == next_move.targ_seg and next_move.targ_pos > next_move.orig_pos:
                    next_move.targ_pos -= 2

                ind.loads[next_move.orig_seg] -= self.tasks[next_move.task1].demand + self.tasks[next_move.task2].demand
                if next_move.targ_seg > ind.loads[0]:
                    ind.task_seq[0] += 3
                    ind.task_seq[ind.task_seq[0] - 2] = next_move.task1
                    ind.task_seq[ind.task_seq[0] - 1] = next_move.task2
                    ind.task_seq[ind.task_seq[0]] = 0
                    ind.loads[0] += 1
                    ind.loads[ind.loads[0]] = inst_tasks[next_move.task1].demand + inst_tasks[next_move.task2].demand
                else:
                    ind.task_seq = add_element(ind.task_seq, next_move.task2, targ_ptr)
                    ind.task_seq = add_element(ind.task_seq, next_move.task1, targ_ptr)
                    ind.loads[next_move.targ_seg] += inst_tasks[next_move.task1].demand + inst_tasks[next_move.task2].demand
            elif next_move.type == 3:
                ind.task_seq[targ_ptr] = next_move.task1
                ind.task_seq[orig_ptr] = next_move.task2
                ind.loads[next_move.orig_seg] -= inst_tasks[next_move.task1].demand - inst_tasks[next_move.task2].demand
                ind.loads[next_move.targ_seg] += inst_tasks[next_move.task1].demand - inst_tasks[next_move.task2].demand

            ind.quality = next_move.quality
            ind.exceed_load = next_move.exceed_load
            ind.fitness = next_move.fitness
            if ind.loads[next_move.orig_seg] == 0:
                if next_move.type == 2 and next_move.orig_seg > next_move.targ_seg:
                    ind.task_seq = del_element(ind.task_seq, orig_ptr + 1)
                else:
                    ind.task_seq = del_element(ind.task_seq, orig_ptr)
                ind.loads = del_element(ind.loads, next_move.orig_seg)
        else:
            # M-S operator (merge and split)
            task_routes[0, 0] = 1
            task_routes[1, 0] = 1
            task_routes[1, 1] = 0
            for i in range(2, ind.task_seq[0] + 1):
                task_routes[task_routes[0, 0], 0] += 1
                task_routes[task_routes[0, 0], task_routes[task_routes[0, 0], 0]] = ind.task_seq[i]

                if ind.task_seq[i] == 0 and i < ind.task_seq[0]:
                    task_routes[0, 0] += 1
                    task_routes[task_routes[0, 0], 0] = 1
                    task_routes[task_routes[0, 0], 1] = 0

            if task_routes[0, 0] < nsize:
                return

            # 计算可能产生的解(extended neighbor)的数量
            routes_index = np.arange(1, task_routes[0, 0] + 1, 1, dtype=int)
            combs = combinations(routes_index, nsize)
            candidate_combs = np.zeros((MAX_ENSSIZE + 1, MAX_NSIZE + 1), dtype=int)
            cnt = 0
            for tup in combs:
                cnt += 1
                candidate_combs[cnt, 0] = nsize
                for j in range(nsize):
                    candidate_combs[cnt, j + 1] = tup[j]
            maxcount = min(cnt, MAX_ENSSIZE)

            next_indi = Solution(None, None, np.inf, np.inf)
            next_indi.fitness = np.inf
            for i in range(1, maxcount + 1):
                lns_routes = candidate_combs[i].copy()

                sel_total_load = 0
                for j in range(1, lns_routes[0] + 1):
                    sel_total_load += ind.loads[lns_routes[j]]

                if sel_total_load > nsize * info.capacity:
                    continue

                serve_mark = np.zeros(MAX_TASK_TAG_LENGTH, dtype=int)
                for j in range(1, lns_routes[0] + 1):
                    routeID = lns_routes[j]
                    for k in range(2, task_routes[routeID, 0]):
                        serve_mark[task_routes[routeID, k]] = 1
                        serve_mark[inst_tasks[task_routes[routeID, k]].inverse] = 1

                tmp_indi = self.path_scanning(serve_mark)

                for j in range(1, task_routes[0, 0] + 1):
                    if j in lns_routes[1:lns_routes[0] + 1]:
                        continue
                    tmp_indi.task_seq[0] -= 1
                    tmp_indi.task_seq = join_routes(tmp_indi.task_seq, task_routes[j])
                    tmp_indi.loads[0] += 1
                    tmp_indi.loads[tmp_indi.loads[0]] = ind.loads[j]
                    tmp_indi.exceed_load += max(ind.loads[j] - info.capacity, 0)

                tmp_indi.quality = self.get_task_seq_cost(tmp_indi.task_seq, inst_tasks)
                # tmp_indi.exceed_load = self.get_exceed_loads(tmp_indi.loads)
                tmp_indi.calculate_fitness(coef)
                if tmp_indi.fitness < next_indi.fitness:
                    next_indi = copy.deepcopy(tmp_indi)

            if next_indi.fitness < ind.fitness:
                ind = copy.deepcopy(next_indi)
        return ind

    def single_insertion(self, ind: Solution, coef):
        """
        Move operator: Single Insertion
         A task is removed from its current position
         and re-inserted into another position of the current solution or a new empty route.

         If the selected task belongs to an edge task, both its directions will
         be considered when inserting the task into the “target position.”

        :param ind: parent
        :return: move generated by Single Insertion
        """
        info = self.info
        inst_tasks = info.tasks
        min_dist = info.min_dist
        capacity = info.capacity

        """将individual 的task_seq转化为task_route格式
        task_routes[0, 0]: #routes
        task_routes[i, 0]: routes[i]的 #tasks
        task_toutes[i, j]: routes[i], task[j]在inst_task中对应的编号
        
        task_routes[i, 0] == 1: 
        
        ind.task_seq[i] == 0: 一条route的终点（下一条route起点）
                        != 0: route上的task在inst_task中的编号
        """
        task_routes[0, 0] = 1
        task_routes[1, 0] = 1
        task_routes[1, 1] = 0
        for i in range(2, ind.task_seq[0] + 1):
            task_routes[task_routes[0, 0], 0] += 1
            task_routes[task_routes[0, 0], task_routes[task_routes[0, 0], 0]] = ind.task_seq[i]
            if ind.task_seq[i] == 0 and i < ind.task_seq[0]:
                task_routes[0, 0] += 1
                task_routes[task_routes[0, 0], 0] = 1
                task_routes[task_routes[0, 0], 1] = 0

        best_move = Move(type=1)
        tmp_move = Move(type=1)
        # task_routes[0, 0]: segment总数
        for s1 in range(1, task_routes[0, 0] + 1):
            # orig_seg: 被remove的task所在的segment
            orig_seg = s1
            # task_routes[seg, 0]: segment中的路径条数
            for i in range(2, task_routes[s1, 0]):
                orig_pos = i
                for s2 in range(1, task_routes[0, 0] + 2):
                    if s2 == s1:
                        continue
                    # s2: 插入的segment
                    targ_seg = s2
                    if s2 > task_routes[0, 0]:
                        exceed_load = ind.exceed_load
                        exceed_load_1_curr = max(ind.loads[s1] - inst_tasks[task_routes[s1, i]].demand - capacity, 0)
                        exceed_load_1_prev = max(ind.loads[s1] - capacity, 0)
                        exceed_load_2_curr = max(inst_tasks[task_routes[s1, i]].demand - capacity, 0)
                        exceed_load_2_prev = 0
                        exceed_load += (exceed_load_1_curr - exceed_load_1_prev) \
                                       + (exceed_load_2_curr - exceed_load_2_prev)
                        exceed_load = max(exceed_load, 0)
                        # exceed_load -= max(ind.loads[s1] - info.capacity, 0)
                        # exceed_load += max(ind.loads[s1] - inst_tasks[task_routes[s1, i]].demand - info.capacity, 0)

                        task1 = task_routes[s1, i]
                        quality = ind.quality \
                                  + min_dist[inst_tasks[task_routes[s1, i - 1]].v, inst_tasks[task_routes[s1, i + 1]].u] \
                                  + min_dist[info.depot, inst_tasks[task1].u] \
                                  + min_dist[inst_tasks[task1].v, info.depot] \
                                  - min_dist[inst_tasks[task_routes[s1, i - 1]].v, inst_tasks[task_routes[s1, i]].u] \
                                  - min_dist[inst_tasks[task_routes[s1, i]].v, inst_tasks[task_routes[s1, i + 1]].u]
                        tmp_move.quality = quality
                        tmp_move.exceed_load = exceed_load
                        tmp_move.calculate_fitness(coef)

                        if tmp_move.fitness < best_move.fitness:
                            best_move.fitness = tmp_move.fitness
                            best_move.task1 = task1
                            best_move.orig_seg = orig_seg
                            best_move.targ_seg = targ_seg
                            best_move.orig_pos = orig_pos
                            best_move.quality = quality
                            best_move.exceed_load = exceed_load
                        continue

                    for j in range(2, task_routes[s2, 0] + 1):
                        if inst_tasks[task_routes[s2, j - 1]].v == inst_tasks[task_routes[s2, j]].u:
                            continue
                        # targ_pos：插入的位置
                        targ_pos = j
                        exceed_load = ind.exceed_load
                        # 计算新route的load
                        exceed_load_1_curr = max(ind.loads[s1] - inst_tasks[task_routes[s1, i]].demand - capacity, 0)
                        exceed_load_1_prev = max(ind.loads[s1] - capacity, 0)
                        exceed_load_2_curr = max(ind.loads[s2] + inst_tasks[task_routes[s1, i]].demand - capacity, 0)
                        exceed_load_2_prev = max(ind.loads[s2] - capacity, 0)
                        exceed_load += (exceed_load_1_curr - exceed_load_1_prev) + (exceed_load_2_curr - exceed_load_2_prev)
                        exceed_load = max(exceed_load, 0)
                        # exceed_load -= max(ind.loads[s1] - info.capacity, 0)
                        # exceed_load -= max(ind.loads[s2] - info.capacity, 0)
                        # exceed_load += max(ind.loads[s1] - inst_tasks[task_routes[s1, i]].demand - info.capacity, 0)
                        # exceed_load += max(ind.loads[s2] + inst_tasks[task_routes[s1, i]].demand - info.capacity, 0)

                        task1 = task_routes[s1, i]
                        quality = ind.quality \
                                  + min_dist[inst_tasks[task_routes[s1, i - 1]].v, inst_tasks[task_routes[s1, i + 1]].u] \
                                  - min_dist[inst_tasks[task_routes[s1, i - 1]].v, inst_tasks[task_routes[s1, i]].u] \
                                  - min_dist[inst_tasks[task_routes[s1, i]].v, inst_tasks[task_routes[s1, i + 1]].u] \
                                  + min_dist[inst_tasks[task_routes[s2, j - 1]].v, inst_tasks[task1].u] \
                                  + min_dist[inst_tasks[task1].v, inst_tasks[task_routes[s2, j]].u] \
                                  - min_dist[inst_tasks[task_routes[s2, j - 1]].v, inst_tasks[task_routes[s2, j]].u]
                        tmp_move.quality = quality
                        tmp_move.exceed_load = exceed_load
                        tmp_move.calculate_fitness(coef)

                        if tmp_move.fitness < best_move.fitness:
                            best_move.fitness = tmp_move.fitness
                            best_move.task1 = task1
                            best_move.orig_seg = orig_seg
                            best_move.targ_seg = targ_seg
                            best_move.orig_pos = orig_pos
                            best_move.targ_pos = targ_pos
                            best_move.quality = quality
                            best_move.exceed_load = exceed_load

                        task1 = inst_tasks[task_routes[s1, i]].inverse
                        quality = ind.quality \
                                  + min_dist[inst_tasks[task_routes[s1, i - 1]].v, inst_tasks[task_routes[s1, i + 1]].u] \
                                  - min_dist[inst_tasks[task_routes[s1, i - 1]].v, inst_tasks[task_routes[s1, i]].u] \
                                  - min_dist[inst_tasks[task_routes[s1, i]].v, inst_tasks[task_routes[s1, i + 1]].u] \
                                  + min_dist[inst_tasks[task_routes[s2, j - 1]].v, inst_tasks[task1].u] \
                                  + min_dist[inst_tasks[task1].v, inst_tasks[task_routes[s2, j]].u] \
                                  - min_dist[inst_tasks[task_routes[s2, j - 1]].v, inst_tasks[task_routes[s2, j]].u]
                        tmp_move.quality = quality
                        tmp_move.exceed_load = exceed_load
                        tmp_move.calculate_fitness(coef)

                        if tmp_move.fitness < best_move.fitness:
                            best_move.fitness = tmp_move.fitness
                            best_move.task1 = task1
                            best_move.orig_seg = orig_seg
                            best_move.targ_seg = targ_seg
                            best_move.orig_pos = orig_pos
                            best_move.targ_pos = targ_pos
                            best_move.quality = quality
                            best_move.exceed_load = exceed_load
        return best_move

    def double_insertion(self, ind: Solution, coef):
        """double insertion:
        similar to single insertion.
        two consecutive tasks are moved instead of a single task
        :return: best move
        """
        info = self.info
        inst_tasks = info.tasks
        min_dist = info.min_dist
        capacity = info.capacity

        task_routes[0, 0] = 1
        task_routes[1, 0] = 1
        task_routes[1, 1] = 0
        for i in range(2, ind.task_seq[0] + 1):
            task_routes[task_routes[0, 0], 0] += 1
            task_routes[task_routes[0, 0], task_routes[task_routes[0, 0], 0]] = ind.task_seq[i]
            if ind.task_seq[i] == 0 and i < ind.task_seq[0]:
                task_routes[0, 0] += 1
                task_routes[task_routes[0, 0], 0] = 1
                task_routes[task_routes[0, 0], 1] = 0

        best_move = Move(type=2)
        tmp_move = Move(type=2)
        for s1 in range(1, task_routes[0, 0] + 1):
            if task_routes[s1, 0] < 4:
                continue

            orig_seg = s1
            for i in range(2, task_routes[s1, 0] - 1):
                orig_pos = i
                for s2 in range(1, task_routes[0, 0] + 2):
                    if s2 == s1:
                        continue
                    targ_seg = s2
                    if s2 > task_routes[0, 0]:
                        if task_routes[s1, 0] <= 4:
                            continue
                        exceed_load = ind.exceed_load
                        exceed_load_1_curr = max(ind.loads[s1] \
                                             - inst_tasks[task_routes[s1, i]].demand \
                                             - inst_tasks[task_routes[s1, i+1]].demand \
                                             - capacity, 0)
                        exceed_load_1_prev = max(ind.loads[s1] - capacity, 0)
                        exceed_load_2_curr = max(ind.loads[s2] \
                                             + inst_tasks[task_routes[s1, i]].demand \
                                             + inst_tasks[task_routes[s1, i+1]].demand \
                                             - capacity, 0)
                        exceed_load_2_prev = 0
                        exceed_load += (exceed_load_1_curr - exceed_load_1_prev) \
                                       + (exceed_load_2_curr - exceed_load_2_prev)
                        exceed_load = max(exceed_load, 0)
                        # exceed_load -= max(ind.loads[s1] - info.capacity, 0)
                        # exceed_load += max(ind.loads[s1] - inst_tasks[task_routes[s1, i]].demand \
                        #                    - inst_tasks[task_routes[s1, i + 1]].demand \
                        #                    - info.capacity, 0)
                        # exceed_load += max(inst_tasks[task_routes[s1, i]].demand \
                        #                    + inst_tasks[task_routes[s1, i + 1]].demand \
                        #                    - info.capacity, 0)

                        task1 = task_routes[s1, i]
                        task2 = task_routes[s1, i + 1]
                        quality = ind.quality \
                                  + min_dist[inst_tasks[task_routes[s1, i - 1]].v, inst_tasks[task_routes[s1, i + 2]].u] \
                                  - min_dist[inst_tasks[task_routes[s1, i - 1]].v, inst_tasks[task_routes[s1, i]].u] \
                                  - min_dist[inst_tasks[task_routes[s1, i]].v, inst_tasks[task_routes[s1, i + 1]].u] \
                                  - min_dist[inst_tasks[task_routes[s1, i + 1]].v, inst_tasks[task_routes[s1, i + 2]].u] \
                                  + min_dist[info.depot, inst_tasks[task1].u] \
                                  + min_dist[inst_tasks[task1].v, inst_tasks[task2].u] \
                                  + min_dist[inst_tasks[task2].v, info.depot]
                        tmp_move.quality = quality
                        tmp_move.exceed_load = exceed_load
                        tmp_move.calculate_fitness(coef)

                        if tmp_move.fitness < best_move.fitness:
                            best_move.fitness = tmp_move.fitness
                            best_move.task1 = task1
                            best_move.task2 = task2
                            best_move.orig_seg = orig_seg
                            best_move.targ_seg = targ_seg
                            best_move.orig_pos = orig_pos
                            best_move.quality = quality
                            best_move.exceed_load = exceed_load

                        task1 = task_routes[s1, i]
                        task2 = inst_tasks[task_routes[s1, i + 1]].inverse

                        quality = ind.quality \
                                  + min_dist[inst_tasks[task_routes[s1, i - 1]].v, inst_tasks[task_routes[s1, i + 2]].u] \
                                  - min_dist[inst_tasks[task_routes[s1, i - 1]].v, inst_tasks[task_routes[s1, i]].u] \
                                  - min_dist[inst_tasks[task_routes[s1, i]].v, inst_tasks[task_routes[s1, i + 1]].u] \
                                  - min_dist[inst_tasks[task_routes[s1, i + 1]].v, inst_tasks[task_routes[s1, i + 2]].u] \
                                  + min_dist[info.depot, inst_tasks[task1].u] \
                                  + min_dist[inst_tasks[task1].v, inst_tasks[task2].u] \
                                  + min_dist[inst_tasks[task2].v, info.depot]
                        tmp_move.quality = quality
                        tmp_move.exceed_load = exceed_load
                        tmp_move.calculate_fitness(coef)

                        if tmp_move.fitness < best_move.fitness:
                            best_move.fitness = tmp_move.fitness
                            best_move.task1 = task1
                            best_move.task2 = task2
                            best_move.orig_seg = orig_seg
                            best_move.targ_seg = targ_seg
                            best_move.orig_pos = orig_pos
                            best_move.quality = quality
                            best_move.exceed_load = exceed_load

                        task1 = inst_tasks[task_routes[s1, i]].inverse
                        task2 = task_routes[s1, i + 1]
                        quality = ind.quality \
                                  + min_dist[inst_tasks[task_routes[s1, i - 1]].v, inst_tasks[task_routes[s1, i + 2]].u] \
                                  - min_dist[inst_tasks[task_routes[s1, i - 1]].v, inst_tasks[task_routes[s1, i]].u] \
                                  - min_dist[inst_tasks[task_routes[s1, i]].v, inst_tasks[task_routes[s1, i + 1]].u] \
                                  - min_dist[inst_tasks[task_routes[s1, i + 1]].v, inst_tasks[task_routes[s1, i + 2]].u] \
                                  + min_dist[info.depot, inst_tasks[task1].u] \
                                  + min_dist[inst_tasks[task1].v, inst_tasks[task2].u] \
                                  + min_dist[inst_tasks[task2].v, info.depot]
                        tmp_move.quality = quality
                        tmp_move.exceed_load = exceed_load
                        tmp_move.calculate_fitness(coef)

                        if tmp_move.fitness < best_move.fitness:
                            best_move.fitness = tmp_move.fitness
                            best_move.task1 = task1
                            best_move.task2 = task2
                            best_move.orig_seg = orig_seg
                            best_move.targ_seg = targ_seg
                            best_move.orig_pos = orig_pos
                            best_move.quality = quality
                            best_move.exceed_load = exceed_load

                        task1 = inst_tasks[task_routes[s1, i]].inverse
                        task2 = inst_tasks[task_routes[s1, i + 1]].inverse
                        quality = ind.quality \
                                  + min_dist[inst_tasks[task_routes[s1, i - 1]].v, inst_tasks[task_routes[s1, i + 2]].u] \
                                  - min_dist[inst_tasks[task_routes[s1, i - 1]].v, inst_tasks[task_routes[s1, i]].u] \
                                  - min_dist[inst_tasks[task_routes[s1, i]].v, inst_tasks[task_routes[s1, i + 1]].u] \
                                  - min_dist[inst_tasks[task_routes[s1, i + 1]].v, inst_tasks[task_routes[s1, i + 2]].u] \
                                  + min_dist[info.depot, inst_tasks[task1].u] \
                                  + min_dist[inst_tasks[task1].v, inst_tasks[task2].u] \
                                  + min_dist[inst_tasks[task2].v, info.depot]
                        tmp_move.quality = quality
                        tmp_move.exceed_load = exceed_load
                        tmp_move.calculate_fitness(coef)

                        if tmp_move.fitness < best_move.fitness:
                            best_move.fitness = tmp_move.fitness
                            best_move.task1 = task1
                            best_move.task2 = task2
                            best_move.orig_seg = orig_seg
                            best_move.targ_seg = targ_seg
                            best_move.orig_pos = orig_pos
                            best_move.quality = quality
                            best_move.exceed_load = exceed_load
                        continue

                    for j in range(2, task_routes[s2, 0] + 1):
                        if inst_tasks[task_routes[s2, j - 1]].v == inst_tasks[task_routes[s2, j]].u:
                            continue
                        targ_pos = j
                        exceed_load = ind.exceed_load
                        exceed_load_1_curr = max(ind.loads[s1] \
                                             - inst_tasks[task_routes[s1, i]].demand \
                                             - inst_tasks[task_routes[s1, i+1]].demand \
                                             - capacity, 0)
                        exceed_load_1_prev = max(ind.loads[s1] - capacity, 0)
                        exceed_load_2_curr = max(ind.loads[s2] \
                                             + inst_tasks[task_routes[s1, i]].demand \
                                             + inst_tasks[task_routes[s1, i+1]].demand \
                                             - capacity, 0)
                        exceed_load_2_prev = max(ind.loads[s2] - capacity, 0)
                        exceed_load += (exceed_load_1_curr - exceed_load_1_prev) \
                                       + (exceed_load_2_curr - exceed_load_2_prev)
                        exceed_load = max(exceed_load, 0)
                        # exceed_load -= max(ind.loads[s1] - info.capacity, 0)
                        # exceed_load -= max(ind.loads[s2] - info.capacity, 0)
                        # exceed_load += max(ind.loads[s1] \
                        #                    - inst_tasks[task_routes[s1, i]].demand \
                        #                    - inst_tasks[task_routes[s1, i + 1]].demand \
                        #                    - info.capacity, 0)
                        # exceed_load += max(ind.loads[s2] \
                        #                    + inst_tasks[task_routes[s1, i]].demand \
                        #                    + inst_tasks[task_routes[s1, i + 1]].demand \
                        #                    - info.capacity, 0)

                        task1 = task_routes[s1, i]
                        task2 = task_routes[s1, i + 1]

                        quality = ind.quality \
                                  + min_dist[inst_tasks[task_routes[s1, i - 1]].v, inst_tasks[task_routes[s1, i + 2]].u] \
                                  - min_dist[inst_tasks[task_routes[s1, i - 1]].v, inst_tasks[task_routes[s1, i]].u] \
                                  - min_dist[inst_tasks[task_routes[s1, i]].v, inst_tasks[task_routes[s1, i + 1]].u] \
                                  - min_dist[inst_tasks[task_routes[s1, i + 1]].v, inst_tasks[task_routes[s1, i + 2]].u] \
                                  + min_dist[inst_tasks[task_routes[s2, j - 1]].v, inst_tasks[task1].u] \
                                  + min_dist[inst_tasks[task1].v, inst_tasks[task2].u] \
                                  + min_dist[inst_tasks[task2].v, inst_tasks[task_routes[s2, j]].u] \
                                  - min_dist[inst_tasks[task_routes[s2, j - 1]].v, inst_tasks[task_routes[s2, j]].u]
                        tmp_move.quality = quality
                        tmp_move.exceed_load = exceed_load
                        tmp_move.calculate_fitness(coef)

                        if tmp_move.fitness < best_move.fitness:
                            best_move.fitness = tmp_move.fitness
                            best_move.task1 = task1
                            best_move.task2 = task2
                            best_move.orig_seg = orig_seg
                            best_move.targ_seg = targ_seg
                            best_move.orig_pos = orig_pos
                            best_move.targ_pos = targ_pos
                            best_move.quality = quality
                            best_move.exceed_load = exceed_load

                        task1 = inst_tasks[task_routes[s1, i]].inverse
                        task2 = task_routes[s1, i + 1]
                        quality = ind.quality \
                                  + min_dist[inst_tasks[task_routes[s1, i - 1]].v, inst_tasks[task_routes[s1, i + 2]].u] \
                                  - min_dist[inst_tasks[task_routes[s1, i - 1]].v, inst_tasks[task_routes[s1, i]].u] \
                                  - min_dist[inst_tasks[task_routes[s1, i]].v, inst_tasks[task_routes[s1, i + 1]].u] \
                                  - min_dist[inst_tasks[task_routes[s1, i + 1]].v, inst_tasks[task_routes[s1, i + 2]].u] \
                                  + min_dist[inst_tasks[task_routes[s2, j - 1]].v, inst_tasks[task1].u] \
                                  + min_dist[inst_tasks[task1].v, inst_tasks[task2].u] \
                                  + min_dist[inst_tasks[task2].v, inst_tasks[task_routes[s2, j]].u] \
                                  - min_dist[inst_tasks[task_routes[s2, j - 1]].v, inst_tasks[task_routes[s2, j]].u]
                        tmp_move.quality = quality
                        tmp_move.exceed_load = exceed_load
                        tmp_move.calculate_fitness(coef)

                        if tmp_move.fitness < best_move.fitness:
                            best_move.fitness = tmp_move.fitness
                            best_move.task1 = task1
                            best_move.task2 = task2
                            best_move.orig_seg = orig_seg
                            best_move.targ_seg = targ_seg
                            best_move.orig_pos = orig_pos
                            best_move.targ_pos = targ_pos
                            best_move.quality = quality
                            best_move.exceed_load = exceed_load

                        task1 = task_routes[s1, i]
                        task2 = inst_tasks[task_routes[s1, i + 1]].inverse
                        quality = ind.quality \
                                  + min_dist[inst_tasks[task_routes[s1, i - 1]].v, inst_tasks[task_routes[s1, i + 2]].u] \
                                  - min_dist[inst_tasks[task_routes[s1, i - 1]].v, inst_tasks[task_routes[s1, i]].u] \
                                  - min_dist[inst_tasks[task_routes[s1, i]].v, inst_tasks[task_routes[s1, i + 1]].u] \
                                  - min_dist[inst_tasks[task_routes[s1, i + 1]].v, inst_tasks[task_routes[s1, i + 2]].u] \
                                  + min_dist[inst_tasks[task_routes[s2, j - 1]].v, inst_tasks[task1].u] \
                                  + min_dist[inst_tasks[task1].v, inst_tasks[task2].u] \
                                  + min_dist[inst_tasks[task2].v, inst_tasks[task_routes[s2, j]].u] \
                                  - min_dist[inst_tasks[task_routes[s2, j - 1]].v, inst_tasks[task_routes[s2, j]].u]
                        tmp_move.quality = quality
                        tmp_move.exceed_load = exceed_load
                        tmp_move.calculate_fitness(coef)

                        if tmp_move.fitness < best_move.fitness:
                            best_move.fitness = tmp_move.fitness
                            best_move.task1 = task1
                            best_move.task2 = task2
                            best_move.orig_seg = orig_seg
                            best_move.targ_seg = targ_seg
                            best_move.orig_pos = orig_pos
                            best_move.targ_pos = targ_pos
                            best_move.quality = quality
                            best_move.exceed_load = exceed_load

                        task1 = inst_tasks[task_routes[s1, i]].inverse
                        task2 = inst_tasks[task_routes[s1, i + 1]].inverse
                        quality = ind.quality \
                                  + min_dist[inst_tasks[task_routes[s1, i - 1]].v, inst_tasks[task_routes[s1, i + 2]].u] \
                                  - min_dist[inst_tasks[task_routes[s1, i - 1]].v, inst_tasks[task_routes[s1, i]].u] \
                                  - min_dist[inst_tasks[task_routes[s1, i]].v, inst_tasks[task_routes[s1, i + 1]].u] \
                                  - min_dist[inst_tasks[task_routes[s1, i + 1]].v, inst_tasks[task_routes[s1, i + 2]].u] \
                                  + min_dist[inst_tasks[task_routes[s2, j - 1]].v, inst_tasks[task1].u] \
                                  + min_dist[inst_tasks[task1].v, inst_tasks[task2].u] \
                                  + min_dist[inst_tasks[task2].v, inst_tasks[task_routes[s2, j]].u] \
                                  - min_dist[inst_tasks[task_routes[s2, j - 1]].v, inst_tasks[task_routes[s2, j]].u]
                        tmp_move.quality = quality
                        tmp_move.exceed_load = exceed_load
                        tmp_move.calculate_fitness(coef)

                        if tmp_move.fitness < best_move.fitness:
                            best_move.fitness = tmp_move.fitness
                            best_move.task1 = task1
                            best_move.task2 = task2
                            best_move.orig_seg = orig_seg
                            best_move.targ_seg = targ_seg
                            best_move.orig_pos = orig_pos
                            best_move.targ_pos = targ_pos
                            best_move.quality = quality
                            best_move.exceed_load = exceed_load
        return best_move

    def swap(self, ind: Solution, coef):
        info = self.info
        inst_tasks = info.tasks
        min_dist = info.min_dist
        capacity = info.capacity

        task_routes[0, 0] = 1
        task_routes[1, 0] = 1
        task_routes[1, 1] = 0
        for i in range(2, ind.task_seq[0] + 1):
            task_routes[task_routes[0, 0], 0] += 1
            task_routes[task_routes[0, 0], task_routes[task_routes[0, 0], 0]] = ind.task_seq[i]
            if ind.task_seq[i] == 0 and i < ind.task_seq[0]:
                task_routes[0, 0] += 1
                task_routes[task_routes[0, 0], 0] = 1
                task_routes[task_routes[0, 0], 1] = 0

        best_move = Move(type=3)
        tmp_move = Move(type=3)
        for s1 in range(1, task_routes[0, 0] + 1):
            orig_seg = s1
            for i in range(2, task_routes[s1, 0]):
                if inst_tasks[task_routes[s1, i - 1]].v == inst_tasks[task_routes[s1, i]].u and \
                        inst_tasks[task_routes[s1, i]].v == inst_tasks[task_routes[s1, i + 1]].u:
                    continue
                orig_pos = i
                for s2 in range(s1 + 1, task_routes[0, 0] + 1):
                    targ_seg = s2
                    for j in range(2, task_routes[s2, 0]):
                        if inst_tasks[task_routes[s2, j - 1]].v == inst_tasks[task_routes[s2, j]].u and \
                                inst_tasks[task_routes[s2, j]].v == inst_tasks[task_routes[s2, j + 1]].u:
                            continue
                        targ_pos = j
                        exceed_load = ind.exceed_load
                        exceed_load_1_curr = max(ind.loads[s1]
                                                 - inst_tasks[task_routes[s1, i]].demand
                                                 + inst_tasks[task_routes[s2, j]].demand
                                                 - capacity, 0)
                        exceed_load_1_prev = max(ind.loads[s1] - capacity, 0)
                        exceed_load_2_curr = max(ind.loads[s2]
                                                 + inst_tasks[task_routes[s1, i]].demand
                                                 - inst_tasks[task_routes[s2, j]].demand
                                                 - capacity, 0)
                        exceed_load_2_prev = max(ind.loads[s2] - capacity, 0)
                        exceed_load += (exceed_load_1_curr - exceed_load_1_prev) \
                                       + (exceed_load_2_curr - exceed_load_2_prev)
                        exceed_load = max(exceed_load, 0)

                        # exceed_load -= max(ind.loads[s1] - info.capacity, 0)
                        # exceed_load -= max(ind.loads[s2] - info.capacity, 0)
                        # exceed_load += max(ind.loads[s1] \
                        #                    - inst_tasks[task_routes[s1, i]].demand \
                        #                    + inst_tasks[task_routes[s2, j]].demand \
                        #                    - info.capacity, 0)
                        # exceed_load += max(ind.loads[s2] \
                        #                    + inst_tasks[task_routes[s1, i]].demand \
                        #                    - inst_tasks[task_routes[s2, j]].demand \
                        #                    - info.capacity, 0)

                        cand_task1 = [task_routes[s1, i], inst_tasks[task_routes[s1, i]].inverse]
                        cand_task2 = [task_routes[s2, j], inst_tasks[task_routes[s2, j]].inverse]
                        for task1 in cand_task1:
                            for task2 in cand_task2:
                                quality = ind.quality \
                                          - min_dist[inst_tasks[task_routes[s1, i - 1]].v, inst_tasks[task_routes[s1, i]].u] \
                                          - min_dist[inst_tasks[task_routes[s1, i]].v, inst_tasks[task_routes[s1, i + 1]].u] \
                                          + min_dist[inst_tasks[task_routes[s1, i - 1]].v, inst_tasks[task2].u] \
                                          + min_dist[inst_tasks[task2].v, inst_tasks[task_routes[s1, i + 1]].u] \
                                          - min_dist[inst_tasks[task_routes[s2, j - 1]].v, inst_tasks[task_routes[s2, j]].u] \
                                          - min_dist[inst_tasks[task_routes[s2, j]].v, inst_tasks[task_routes[s2, j + 1]].u] \
                                          + min_dist[inst_tasks[task_routes[s2, j - 1]].v, inst_tasks[task1].u] \
                                          + min_dist[inst_tasks[task1].v, inst_tasks[task_routes[s2, j + 1]].u]
                                tmp_move.quality = quality
                                tmp_move.exceed_load = exceed_load
                                tmp_move.calculate_fitness(coef)

                                if tmp_move.fitness < best_move.fitness:
                                    best_move.fitness = tmp_move.fitness
                                    best_move.task1 = task1
                                    best_move.task2 = task2
                                    best_move.orig_seg = orig_seg
                                    best_move.targ_seg = targ_seg
                                    best_move.orig_pos = orig_pos
                                    best_move.targ_pos = targ_pos
                                    best_move.quality = quality
                                    best_move.exceed_load = exceed_load

        return best_move

    def initialize(self):
        task_num = self.info.edges_required * 2
        population = []
        best_fsb_solution = Solution(None, None, np.inf, np.inf)
        # population.append(best_fsb_solution)
        while len(population) < self.psize:
            trial = 0
            while trial < Mtrial:
                serve_mark = np.zeros(MAX_TASK_TAG_LENGTH, dtype=int)
                serve_mark[1:task_num + 1] = 1
                init_ind = self.rand_scanning(serve_mark)
                if init_ind in population and trial != Mtrial:
                    continue
                elif trial == Mtrial:
                    break
                population.append(init_ind)
                if init_ind.exceed_load == 0 and init_ind.quality < best_fsb_solution.quality:
                    best_fsb_solution = init_ind
                break
        self.psize = len(population)
        self.opsize = 6 * self.psize
        self.total_size = self.psize + self.opsize
        self.population = [None] * (self.total_size)
        self.population[:self.psize] = population
        return best_fsb_solution

    def random_select(self):
        s1_idx = random.randrange(0, self.psize)
        s2_idx = random.randrange(0, self.psize)
        while s1_idx == s2_idx:
            s2_idx = random.randrange(0, self.psize)
        s1 = self.population[s1_idx]
        s2 = self.population[s2_idx]
        return s1, s2

    def stochastic_rank(self):
        pf = 0.45
        total_size = self.total_size
        for i in range(total_size):
            for j in range(i):
                r = random.random()
                if (self.population[j].exceed_load == 0 and self.population[j + 1].exceed_load == 0) \
                        or r < pf:
                    if self.population[j].quality > self.population[j + 1].quality:
                        self.population[j], self.population[j + 1] = self.population[j + 1], self.population[j]
                elif self.population[j].exceed_load > self.population[j + 1].exceed_load:
                    self.population[j], self.population[j + 1] = self.population[j + 1], self.population[j]


    def maens(self):
        best_fsb_solution = self.initialize()
        total_size = self.total_size
        counter = 0
        wite = 0
        old_best = Solution(None, None, np.inf, 0)
        # while counter < self.Gmax:
        while counter < 3:
            counter += 1
            wite += 1
            ptr = self.psize
            child = Solution(None, None, -1, -1)
            while ptr < total_size:
                # randomly select two parents
                s1, s2 = self.random_select()
                # crossover
                sx = self.SBX(s1, s2)
                if sx.exceed_load == 0 and sx.quality < best_fsb_solution.quality:
                    best_fsb_solution = sx
                    wite = 0

                # add sx into population if not exsist
                if sx not in self.population[:ptr]:
                    child = sx

                # local search with probability
                r = random.random()
                if r < self.pls:
                    # do local search
                    sls, best_fsb_solution = self.lns_mut(sx, best_fsb_solution)
                    if sls not in self.population[:ptr]:
                        child = sls

                if child.quality > 0 and child != s1 and child != s2:
                    self.population[ptr] = child
                    ptr += 1

            # stochastic ranking
            self.stochastic_rank()

            if best_fsb_solution.quality < old_best.quality:
                old_best = best_fsb_solution
            print('MAENS: ', counter, ' ', best_fsb_solution.quality)
        return old_best

    def solve(self):
        total_size = self.total_size

        # stochastic ranking
        self.stochastic_rank()

        ptr = self.psize
        child = Solution(None, None, -1, -1)
        while ptr < total_size:
            # randomly select two parents
            s1, s2 = self.random_select()
            # crossover
            sx = self.SBX(s1, s2)
            if sx.exceed_load == 0 and sx.quality < best_fsb_solution.quality:
                best_fsb_solution = sx
                wite = 0

            # add sx into population if not exsist
            if sx not in self.population[:ptr]:
                child = sx

            # local search with probability
            r = random.random()
            if r < self.pls:
                # do local search
                sls, best_fsb_solution = self.lns_mut(sx, best_fsb_solution)
                if sls not in self.population[:ptr]:
                    child = sls

            if child.quality > 0 and child != s1 and child != s2:
                self.population[ptr] = child
                ptr += 1
        return best_fsb_solution